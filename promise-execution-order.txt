Hereâ€™s your example with **better console logs** to clearly show the execution order:  

```js
console.log("ðŸš€ Step 1: Script starts");

let x = new Promise((res, rej) => {
    console.log("ðŸ”„ Step 2: Inside Promise executor function (Runs immediately)");
    res("âœ… Step 4: Promise resolved with success");
});

console.log("ðŸ•’ Step 3: Script continues executing after Promise creation");

x.then((res) => console.log(res)).catch();
```

### **ðŸ”¹ Expected Output**
```
ðŸš€ Step 1: Script starts
ðŸ”„ Step 2: Inside Promise executor function (Runs immediately)
ðŸ•’ Step 3: Script continues executing after Promise creation
âœ… Step 4: Promise resolved with success
```

### **ðŸ”¹ Explanation (Step-by-Step)**
1ï¸âƒ£ `console.log("ðŸš€ Step 1: Script starts");`  
   - Prints **before** the Promise is created.  

2ï¸âƒ£ The **Promise executor function** (`(res, rej) => {...}`) runs **immediately**, so:
   - `console.log("ðŸ”„ Step 2: Inside Promise executor function (Runs immediately)");` executes **synchronously**.  
   - `res("âœ… Step 4: Promise resolved with success");` resolves the Promise but does **not** execute `.then()` yet.  

3ï¸âƒ£ `console.log("ðŸ•’ Step 3: Script continues executing after Promise creation");`  
   - Runs **before `.then()`**, because **JavaScript doesnâ€™t wait** for the Promise to resolve.  

4ï¸âƒ£ `.then((res) => console.log(res));`  
   - Runs **after the current execution stack finishes** (async behavior).  
   - Logs `"âœ… Step 4: Promise resolved with success"`.  

---

### **ðŸ”¹ Key Takeaways**
âœ… **Promise executor runs synchronously** when the Promise is created.  
âœ… **`.then()` runs asynchronously** in the next event loop cycle.  
âœ… **JavaScript does not wait** for the Promise to resolve before moving to the next line.  

Would you like me to add an example with `setTimeout` to demonstrate async behavior? ðŸš€
Yes, **`var` is hoisted within its scope**, but its behavior depends on whether it's inside a **function scope** or **global scope**:

### **ðŸ”¹ `var` Hoisting Behavior**
1. **Hoisted to the top of its scope but remains `undefined` until assigned**  
2. **Function-scoped (not block-scoped like `let` or `const`)**  
3. **Can be redeclared within the same scope without errors**

---

### **âœ… Example 1: Hoisting in Global Scope**
```js
console.log(a); // âœ… `undefined` (Hoisted but not initialized)
var a = 10;
console.log(a); // 10
```
ðŸ”¹ **Explanation:**  
- `var a;` is hoisted to the top, but its value (`10`) is assigned later.
- Until the assignment happens, `a` is `undefined`.

---

### **âœ… Example 2: Hoisting in Function Scope**
```js
function test() {
  console.log(b); // âœ… `undefined` (Hoisted inside function)
  var b = 20;
  console.log(b); // 20
}
test();
```
ðŸ”¹ **Explanation:**  
- `var b;` is hoisted inside `test()` but not initialized.
- Accessing `b` before assignment returns `undefined`.

---

### **ðŸš¨ Example 3: `var` is NOT Block-Scoped**
```js
if (true) {
  var x = 30;
}
console.log(x); // âœ… 30 (Accessible outside the block)
```
ðŸ”¹ **Explanation:**  
- `var x;` is hoisted **inside the function scope** (or globally).
- Unlike `let`/`const`, it **doesnâ€™t respect block scope**, so `x` is still accessible outside the `if` block.

---

### **ðŸ’¡ Key Takeaways**
âœ” **Hoisted within its function/global scope**  
âœ” **Can be accessed before declaration but is `undefined`**  
âœ” **Doesnâ€™t respect block scope (bad for maintainability)**  

Would you like an explanation of `let` and `const` hoisting for comparison? ðŸš€